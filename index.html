<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream Rewards - Automated File Manager</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(45deg, #4a90e2, #357abd);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .section {
            margin-bottom: 40px;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #4a90e2;
        }

        .section h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }

        .button {
            background: linear-gradient(45deg, #4a90e2, #357abd);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 5px;
            box-shadow: 0 4px 15px rgba(74, 144, 226, 0.3);
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 144, 226, 0.4);
        }

        .button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .button.danger {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .button.success {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 600;
        }

        .status.info {
            background: #d6eaf8;
            color: #2980b9;
            border-left: 4px solid #3498db;
        }

        .status.success {
            background: #d5f4e6;
            color: #27ae60;
            border-left: 4px solid #2ecc71;
        }

        .status.error {
            background: #fadbd8;
            color: #e74c3c;
            border-left: 4px solid #e74c3c;
        }

        .status.warning {
            background: #fcf3cf;
            color: #d68910;
            border-left: 4px solid #f39c12;
        }

        .file-list {
            max-height: 400px;
            overflow-y: auto;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            background: white;
        }

        .file-item {
            padding: 15px;
            border-bottom: 1px solid #e1e8ed;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s ease;
        }

        .file-item:hover {
            background: #f8f9fa;
        }

        .file-item:last-child {
            border-bottom: none;
        }

        .file-name {
            font-family: 'Courier New', monospace;
            background: #f1f3f4;
            padding: 5px 10px;
            border-radius: 4px;
            margin: 0 10px;
        }

        .file-type {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .file-type.image {
            background: #e8f5e8;
            color: #2e7d32;
        }

        .file-type.video {
            background: #fff3e0;
            color: #e65100;
        }

        .file-type.gif {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        .arrow {
            color: #4a90e2;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #4a90e2;
        }

        .stat-label {
            color: #666;
            margin-top: 5px;
        }

        .loading {
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4a90e2;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .github-auth {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #e1e8ed;
            margin-bottom: 20px;
        }

        .input-group {
            margin: 15px 0;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2c3e50;
        }

        .input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e8ed;
            border-radius: 6px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: #4a90e2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }

        .preview-section {
            display: none;
        }

        .preview-section.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÅ Stream Rewards Manager</h1>
            <p>Automated File Renaming & Secure Link Generation</p>
            <div style="font-size: 0.9rem; opacity: 0.8; margin-top: 10px;">
                Version 3.0.0 - Catbox Auto-Upload for Complete Privacy
            </div>
        </div>

        <div class="content">
            <!-- GitHub Authentication Section -->
            <div class="section">
                <h2>üîê GitHub Configuration</h2>
                <div class="github-auth">
                    <div class="input-group">
                        <label for="githubToken">GitHub Personal Access Token:</label>
                        <input type="password" id="githubToken" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx">
                        <small style="color: #666; margin-top: 5px; display: block;">
                            Create at: <a href="https://github.com/settings/tokens" target="_blank">GitHub ‚Üí Settings ‚Üí Developer settings ‚Üí Personal access tokens</a><br>
                            Required permissions: <code>repo</code> (Full control of private repositories)
                        </small>
                    </div>
                    <div class="input-group">
                        <label for="repoOwner">Repository Owner:</label>
                        <input type="text" id="repoOwner" value="KayPikeFashion" placeholder="KayPikeFashion">
                    </div>
                    <div class="input-group">
                        <label for="privateRepoName">Private Repository Name (your files):</label>
                        <input type="text" id="privateRepoName" value="stream_rewards" placeholder="stream_rewards">
                    </div>
                    <div class="input-group">
                        <label for="publicRepoName">Public Repository Name (this tool + manifest):</label>
                        <input type="text" id="publicRepoName" value="stream-rewards-manager" placeholder="stream-rewards-manager">
                    </div>
                    <button class="button" onclick="testConnection()">Test Connection</button>
                    <button class="button danger" onclick="clearSettings()" style="float: right;">Clear Saved Settings</button>
                </div>
                <div id="connectionStatus"></div>
                <div class="status info" style="margin-top: 10px;">
                    ‚ÑπÔ∏è Your token is saved securely in your browser and never exposed publicly. It will auto-fill next time you visit this page.
                </div>
            </div>

            <!-- File Scanner Section -->
            <div class="section">
                <h2>üìÇ Repository Scanner</h2>
                <p>Scan your repository for reward files in the <code>images/follows/</code>, <code>images/subs/</code>, and <code>images/special/</code> folders.</p>
                <button class="button" onclick="scanRepository()" id="scanBtn">üîç Scan Repository</button>
                <div id="scanStatus"></div>
                
                <div class="stats" id="fileStats" style="display: none;">
                    <div class="stat-card">
                        <div class="stat-number" id="followCount">0</div>
                        <div class="stat-label">Follow Rewards</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="subCount">0</div>
                        <div class="stat-label">Sub Rewards</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="specialCount">0</div>
                        <div class="stat-label">Special Rewards</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="totalCount">0</div>
                        <div class="stat-label">Total Files</div>
                    </div>
                </div>
            </div>

            <!-- File Preview Section -->
            <div class="section preview-section" id="previewSection">
                <h2>üìã Current Files</h2>
                <div id="followFiles"></div>
                <div id="subFiles"></div>
                <div id="specialFiles"></div>
            </div>

            <!-- Special Video URLs Management Section -->
            <div class="section" id="specialVideoSection">
                <h2>üé¨ Special Video URLs (High-Value Rewards)</h2>
                <p>Manage external video URLs for large gifts (5+), high donations ($50+), and big cheers (5000+ bits).</p>
                
                <div class="status info">
                    üéØ <strong>Purpose:</strong> Videos for rare, high-value events only.<br>
                    üìπ <strong>Recommended:</strong> Catbox.moe, Streamable.com, or Imgur for reliable video hosting.
                </div>
                
                <div class="input-group">
                    <label for="videoUrlInput">Add Video URL:</label>
                    <input type="url" id="videoUrlInput" placeholder="https://files.catbox.moe/abc123.mp4" onkeypress="if(event.key==='Enter') addVideoUrl()">
                    <button class="button" onclick="addVideoUrl()">‚ûï Add URL</button>
                    <button class="button danger" onclick="clearVideoUrls()" style="margin-left: 10px;" id="clearVideosBtn">üóëÔ∏è Clear All</button>
                </div>
                
                <div id="videoUrlList" style="margin-top: 20px;"></div>
                
                <div class="stats" id="videoStats" style="display: none;">
                    <div class="stat-card">
                        <div class="stat-number" id="videoCount">0</div>
                        <div class="stat-label">Special Videos</div>
                    </div>
                </div>
            </div>

            <!-- Renamer Section -->
            <div class="section">
                <h2>üéØ Automated File Renamer</h2>
                <p>Generate secure, non-spoofable filenames for all your reward files.</p>
                <button class="button" onclick="previewRename()" id="previewBtn" disabled>üëÄ Preview Rename</button>
                <button class="button" onclick="validateBeforeRename()" id="validateBtn" disabled style="display: none; background: linear-gradient(45deg, #f39c12, #e67e22);">üîç Pre-Validate (Recommended for 50+ files)</button>
                <button class="button success" onclick="applyRename()" id="applyBtn" disabled>‚úÖ Apply Rename & Generate Manifest</button>
                <button class="button" onclick="applyRenameWithCatbox()" id="applyBtnCatbox" disabled style="background: linear-gradient(45deg, #e74c3c, #c0392b);">üîí Apply Rename & Upload to Catbox (Private)</button>
                <button class="button" onclick="resumeRename()" id="resumeBtn" disabled style="display: none; background: linear-gradient(45deg, #27ae60, #2ecc71);">‚ñ∂Ô∏è Resume Processing</button>
                <button class="button" onclick="retryManifest()" id="retryManifestBtn" disabled style="display: none;">üîÑ Retry Manifest Generation</button>
                <div id="renameStatus"></div>
                
                <div class="preview-section" id="renamePreview">
                    <h3>üìù Rename Preview</h3>
                    <div id="renameList"></div>
                </div>
            </div>

            <!-- Quick Manifest Regeneration Section -->
            <div class="section">
                <h2>üîÑ Quick Manifest Regeneration</h2>
                <div class="status info">
                    üõ°Ô∏è <strong>Safety Net:</strong> Use this to regenerate your manifest without any file renaming.<br>
                    üìÅ <strong>Perfect for:</strong> When you accidentally generate an empty manifest or add new files to GitHub.<br>
                    üé¨ <strong>Preserves:</strong> All your video URLs and finds existing renamed files automatically.
                </div>
                <button class="button" onclick="regenerateManifestOnly()" id="regenBtn" disabled style="background: linear-gradient(45deg, #9b59b6, #8e44ad);">üîÑ Regenerate Manifest Only</button>
                <button class="button" onclick="regenerateWithCatbox()" id="regenBtnCatbox" disabled style="background: linear-gradient(45deg, #e74c3c, #c0392b); margin-left: 10px;">üîí Regenerate & Upload to Catbox</button>
                <div id="regenStatus"></div>
            </div>

            <!-- Manifest Section -->
            <div class="section">
                <h2>üìÑ StreamerBot Manifest</h2>
                <p>The manifest file contains the mappings that StreamerBot uses for random reward selection.</p>
                <div id="manifestPreview"></div>
                <button class="button" onclick="downloadManifest()" id="downloadBtn" disabled>üì• Download Manifest</button>
            </div>

            <!-- Instructions Section -->
            <div class="section">
                <h2>üìñ How to Use</h2>
                
                <h3>üöÄ Standard Workflow (< 50 files)</h3>
                <ol style="font-size: 1.1rem; line-height: 1.8;">
                    <li><strong>Setup GitHub Token:</strong> Create a personal access token with <code>repo</code> permissions</li>
                    <li><strong>Upload Files:</strong> Add your reward files to <code>images/follows/</code>, <code>images/subs/</code>, and <code>images/special/</code></li>
                    <li><strong>Scan Repository:</strong> Click "Scan Repository" to detect all files</li>
                    <li><strong>Preview Rename:</strong> See what the new secure filenames will look like</li>
                    <li><strong>Apply Changes:</strong> Rename all files and generate manifest.json automatically</li>
                    <li><strong>StreamerBot Setup:</strong> Use the manifest URL in your StreamerBot actions</li>
                </ol>
                
                <h3>üè≠ Enterprise Workflow (50+ files)</h3>
                <ol style="font-size: 1.1rem; line-height: 1.8; background: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 4px solid #f39c12;">
                    <li><strong>Follow Standard Steps 1-4</strong></li>
                    <li><strong>Pre-Validate:</strong> Click "Pre-Validate" to check GitHub API limits and connectivity</li>
                    <li><strong>Review Estimates:</strong> See processing time and API usage estimates</li>
                    <li><strong>Start Batch Processing:</strong> Click "Start Batch Processing" for automated batching with rate limiting</li>
                    <li><strong>Monitor Progress:</strong> Watch real-time progress with ETA and error tracking</li>
                    <li><strong>Resume if Needed:</strong> If interrupted, use "Resume Processing" to continue</li>
                </ol>
                
                <div class="status info" style="margin-top: 15px;">
                    üí° <strong>Pro Tip:</strong> For hundreds of files, the system automatically processes in batches of 10 with 2-second delays to respect GitHub API rate limits. Estimated processing time: ~1 minute per 60 files.
                </div>
                
                <h3>‚ö° Smart Incremental Processing (NEW!)</h3>
                <div class="status success" style="margin-top: 10px;">
                    <strong>üéØ Major Time-Saver for Large Collections!</strong><br><br>
                    
                    The system now <strong>automatically detects already-renamed files</strong> and skips them during processing:<br>
                    ‚úÖ Files matching pattern <code>follow_xxxxxxxx.*</code> are preserved<br>
                    ‚úÖ Files matching pattern <code>sub_xxxxxxxx.*</code> are preserved<br>
                    ‚úÖ Files matching pattern <code>special_xxxxxxxx.*</code> are preserved<br><br>
                    
                    <strong>Example:</strong> If you have 314 already-renamed files and add 4 new wallpapers:<br>
                    ‚Ä¢ Only the 4 new files get processed (saves 98% of processing time!)<br>
                    ‚Ä¢ All 318 files are included in the manifest for StreamerBot<br>
                    ‚Ä¢ Your secure file structure is preserved<br>
                    ‚Ä¢ Zero collision risk - system prevents any name conflicts
                </div>
                
                <h3>üõ°Ô∏è Bulletproof Collision Protection (NEW!)</h3>
                <div class="status info" style="margin-top: 10px;">
                    <strong>üîí Enterprise-Grade Name Collision Prevention</strong><br><br>
                    
                    The system now includes <strong>multiple layers of collision protection</strong>:<br>
                    ‚úÖ <strong>Global name tracking:</strong> Reserves all existing secure names<br>
                    ‚úÖ <strong>Real-time collision detection:</strong> Regenerates names if conflicts detected<br>
                    ‚úÖ <strong>Cross-category protection:</strong> No conflicts between follows/subs/special<br>
                    ‚úÖ <strong>Final validation:</strong> Double-checks entire batch before processing<br>
                    ‚úÖ <strong>Automatic retry:</strong> Up to 1000 attempts per name if needed<br>
                    ‚úÖ <strong>Timestamp fallback:</strong> Guaranteed unique names even in extreme cases<br><br>
                    
                    <strong>Math:</strong> With 36^8 = 2.8 trillion possible combinations and smart collision detection, you can safely process thousands of files with zero risk of overwrites.
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentFiles = { follows: [], subs: [], special: [] };
        let renameMapping = { follows: {}, subs: {}, special: {} };
        let specialVideoUrls = []; // External video URLs for high-value rewards
        let manifestData = {};
        let catboxUrls = {}; // Store Catbox URLs for uploaded files
        
        // Enterprise-grade processing variables
        let processingState = {
            isRunning: false,
            currentBatch: 0,
            totalBatches: 0,
            processed: 0,
            total: 0,
            errors: [],
            completed: [],
            startTime: null
        };

        // Supported file extensions
        const supportedExtensions = ['.png', '.jpg', '.jpeg', '.gif', '.webp', '.mp4', '.mov', '.avi'];
        
        // Smart filtering for already-renamed files
        function isAlreadyRenamed(filename, category) {
            // Patterns: follow_xxxxxxxx.ext, sub_xxxxxxxx.ext, special_xxxxxxxx.ext
            const patterns = {
                'follow': /^follow_[a-z0-9]{8}\.(png|jpg|jpeg|gif|webp|mp4|mov|avi)$/i,
                'sub': /^sub_[a-z0-9]{8}\.(png|jpg|jpeg|gif|webp|mp4|mov|avi)$/i,
                'special': /^special_[a-z0-9]{8}\.(png|jpg|jpeg|gif|webp|mp4|mov|avi)$/i
            };
            
            return patterns[category] && patterns[category].test(filename);
        }
        
        function getFileCategory(filename) {
            if (filename.startsWith('follow_')) return 'follow';
            if (filename.startsWith('sub_')) return 'sub';
            if (filename.startsWith('special_')) return 'special';
            return 'unknown';
        }

        // GitHub API helper functions
        function getGitHubHeaders() {
            const token = document.getElementById('githubToken').value;
            if (!token) {
                throw new Error('GitHub token is required');
            }
            return {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            };
        }

        function getRepoInfo() {
            return {
                owner: document.getElementById('repoOwner').value || 'KayPikeFashion',
                privateRepo: document.getElementById('privateRepoName').value || 'stream_rewards',
                publicRepo: document.getElementById('publicRepoName').value || 'stream-rewards-manager'
            };
        }

        // Test GitHub connection
        async function testConnection() {
            const statusDiv = document.getElementById('connectionStatus');
            const { owner, repo } = getRepoInfo();
            
            try {
                statusDiv.innerHTML = '<div class="status info">Testing connection...</div>';
                
                const response = await fetch(`https://api.github.com/repos/${owner}/${repo}`, {
                    headers: getGitHubHeaders()
                });
                
                if (response.ok) {
                    const repoData = await response.json();
                    
                    // Auto-save settings on successful connection
                    saveSettings();
                    
                    statusDiv.innerHTML = `
                        <div class="status success">
                            ‚úÖ Connection successful! Settings saved.<br>
                            Repository: ${repoData.full_name}<br>
                            Pages URL: <a href="https://${owner.toLowerCase()}.github.io/${repo}" target="_blank">https://${owner.toLowerCase()}.github.io/${repo}</a>
                        </div>`;
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                statusDiv.innerHTML = `<div class="status error">‚ùå Connection failed: ${error.message}</div>`;
            }
        }

        // Scan repository for files
        async function scanRepository() {
            const statusDiv = document.getElementById('scanStatus');
            const scanBtn = document.getElementById('scanBtn');
            const { owner, repo } = getRepoInfo();
            
            try {
                scanBtn.disabled = true;
                statusDiv.innerHTML = '<div class="loading"><div class="spinner"></div>Scanning repository...</div>';
                
                statusDiv.innerHTML = '<div class="loading"><div class="spinner"></div>Scanning for follow rewards...</div>';
                
                // Scan follows folder
                const followsFiles = await scanFolder('images/follows');
                
                statusDiv.innerHTML = '<div class="loading"><div class="spinner"></div>Scanning for sub rewards...</div>';
                
                const subsFiles = await scanFolder('images/subs');
                
                statusDiv.innerHTML = '<div class="loading"><div class="spinner"></div>Scanning for special rewards...</div>';
                
                const specialFiles = await scanFolder('images/special');
                
                currentFiles = { follows: followsFiles, subs: subsFiles, special: specialFiles };
                
                // Update stats
                document.getElementById('followCount').textContent = followsFiles.length;
                document.getElementById('subCount').textContent = subsFiles.length;
                document.getElementById('specialCount').textContent = specialFiles.length;
                document.getElementById('totalCount').textContent = followsFiles.length + subsFiles.length + specialFiles.length;
                document.getElementById('fileStats').style.display = 'grid';
                
                // Display files
                displayFiles();
                
                // Show detected paths info
                let pathInfo = '';
                if (window.detectedPaths) {
                    pathInfo = '<br><strong>Detected folder structure:</strong><br>';
                    Object.entries(window.detectedPaths).forEach(([expected, actual]) => {
                        pathInfo += `üìÅ ${expected} ‚Üí <code>${actual}</code><br>`;
                    });
                }
                
                // Enable buttons
                document.getElementById('previewBtn').disabled = false;
                document.getElementById('regenBtn').disabled = false;
                document.getElementById('regenBtnCatbox').disabled = false;
                document.getElementById('previewSection').classList.add('active');
                
                statusDiv.innerHTML = `<div class="status success">‚úÖ Scan complete! Found ${followsFiles.length} follow rewards, ${subsFiles.length} sub rewards, and ${specialFiles.length} special rewards.${pathInfo}</div>`;
                
            } catch (error) {
                statusDiv.innerHTML = `<div class="status error">‚ùå Scan failed: ${error.message}</div>`;
            } finally {
                scanBtn.disabled = false;
            }
        }

        // Scan specific folder with fallback paths
        async function scanFolder(path) {
            const { owner, repo } = getRepoInfo();
            
            // Try multiple possible paths for the folder
            const possiblePaths = [
                path,                           // e.g., images/follows
                `${repo}/${path}`,             // e.g., stream_rewards/images/follows
                `${repo}/${repo}/${path}`,     // e.g., stream_rewards/stream_rewards/images/follows
            ];
            
            for (const tryPath of possiblePaths) {
                try {
                    const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${tryPath}`, {
                        headers: getGitHubHeaders()
                    });
                    
                    if (response.ok) {
                        const files = await response.json();
                        const filteredFiles = files.filter(file => 
                            file.type === 'file' && 
                            supportedExtensions.some(ext => file.name.toLowerCase().endsWith(ext))
                        );
                        
                        if (filteredFiles.length > 0) {
                            console.log(`Found files in path: ${tryPath}`);
                            // Store the working path for rename operations
                            if (!window.detectedPaths) window.detectedPaths = {};
                            window.detectedPaths[path] = tryPath;
                            return filteredFiles;
                        }
                    }
                    
                } catch (error) {
                    console.warn(`Could not scan ${tryPath}:`, error.message);
                }
            }
            
            console.log(`No files found in any path for ${path}`);
            return [];
        }

        // Display files in preview
        function displayFiles() {
            displayFileCategory('follow', currentFiles.follows);
            displayFileCategory('sub', currentFiles.subs);
            displayFileCategory('special', currentFiles.special);
        }

        function displayFileCategory(category, files) {
            const container = document.getElementById(`${category}Files`);
            if (files.length === 0) {
                container.innerHTML = `<div class="status info">No ${category} reward files found.</div>`;
                return;
            }
            
            let html = `<h3>üìÅ ${category.charAt(0).toUpperCase() + category.slice(1)} Rewards (${files.length})</h3><div class="file-list">`;
            
            files.forEach(file => {
                const fileType = getFileType(file.name);
                html += `
                    <div class="file-item">
                        <span>
                            <span class="file-type ${fileType}">${fileType}</span>
                            <span class="file-name">${file.name}</span>
                        </span>
                        <span>Size: ${formatBytes(file.size)}</span>
                    </div>`;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }

        // Validate no collisions in final rename mapping
        function validateNoCollisions(renameMapping) {
            const allNewNames = new Set();
            const collisions = [];
            
            // Check all categories for collisions
            ['follows', 'subs', 'special'].forEach(category => {
                Object.values(renameMapping[category] || {}).forEach(newFileName => {
                    // Extract the random part (follow_xxxxxxxx.ext -> xxxxxxxx)
                    const match = newFileName.match(/^(follow|sub|special)_([a-z0-9]{8})\./);
                    if (match) {
                        const randomPart = match[2];
                        if (allNewNames.has(randomPart)) {
                            collisions.push({
                                category: category,
                                filename: newFileName,
                                conflictingPart: randomPart
                            });
                        } else {
                            allNewNames.add(randomPart);
                        }
                    }
                });
            });
            
            if (collisions.length > 0) {
                console.error('CRITICAL: Collisions detected in final mapping:', collisions);
                throw new Error(`Collision validation failed: ${collisions.length} naming conflicts detected. This should never happen!`);
            }
            
            console.log(`‚úÖ Collision validation passed: ${allNewNames.size} unique names generated`);
            return true;
        }

        // Generate secure random string with collision detection
        function generateSecureRandomString(length = 8, usedNames = new Set()) {
            const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
            let attempts = 0;
            const maxAttempts = 1000; // Prevent infinite loops
            
            while (attempts < maxAttempts) {
                let result = '';
                const array = new Uint8Array(length);
                crypto.getRandomValues(array);
                
                for (let i = 0; i < length; i++) {
                    result += chars[array[i] % chars.length];
                }
                
                // Check for collision
                if (!usedNames.has(result)) {
                    usedNames.add(result);
                    return result;
                }
                
                attempts++;
                console.warn(`Collision detected for "${result}", regenerating... (attempt ${attempts})`);
            }
            
            // Fallback: append timestamp if max attempts reached
            const fallback = Date.now().toString(36).slice(-8);
            console.error(`Max collision attempts reached, using timestamp fallback: ${fallback}`);
            return fallback;
        }

        // Preview rename operation with smart filtering and collision detection
        function previewRename() {
            renameMapping = { follows: {}, subs: {}, special: {} };
            
            // Global collision tracking across ALL categories and existing files
            const globalUsedNames = new Set();
            let collisionStats = { detected: 0, resolved: 0 };
            
            // First, collect all existing renamed files to prevent collisions
            const allExistingFiles = [...currentFiles.follows, ...currentFiles.subs, ...currentFiles.special];
            allExistingFiles.forEach(file => {
                const category = getFileCategory(file.name);
                if (category !== 'unknown') {
                    // Extract the random part from existing renamed files
                    const match = file.name.match(/^(follow|sub|special)_([a-z0-9]{8})\./);
                    if (match) {
                        globalUsedNames.add(match[2]); // Add the 8-character random part
                        console.log(`Reserved existing name: ${match[2]} from ${file.name}`);
                    }
                }
            });
            
            // Track statistics
            let stats = {
                follows: { total: 0, toRename: 0, alreadyRenamed: 0 },
                subs: { total: 0, toRename: 0, alreadyRenamed: 0 },
                special: { total: 0, toRename: 0, alreadyRenamed: 0 }
            };
            
            // Smart filtering and mapping for follows with collision detection
            currentFiles.follows.forEach(file => {
                stats.follows.total++;
                if (isAlreadyRenamed(file.name, 'follow')) {
                    stats.follows.alreadyRenamed++;
                } else {
                    const extension = file.name.substring(file.name.lastIndexOf('.'));
                    const randomPart = generateSecureRandomString(8, globalUsedNames);
                    const newName = `follow_${randomPart}${extension}`;
                    renameMapping.follows[file.name] = newName;
                    stats.follows.toRename++;
                }
            });
            
            // Smart filtering and mapping for subs with collision detection
            currentFiles.subs.forEach(file => {
                stats.subs.total++;
                if (isAlreadyRenamed(file.name, 'sub')) {
                    stats.subs.alreadyRenamed++;
                } else {
                    const extension = file.name.substring(file.name.lastIndexOf('.'));
                    const randomPart = generateSecureRandomString(8, globalUsedNames);
                    const newName = `sub_${randomPart}${extension}`;
                    renameMapping.subs[file.name] = newName;
                    stats.subs.toRename++;
                }
            });
            
            // Smart filtering and mapping for special with collision detection
            currentFiles.special.forEach(file => {
                stats.special.total++;
                if (isAlreadyRenamed(file.name, 'special')) {
                    stats.special.alreadyRenamed++;
                } else {
                    const extension = file.name.substring(file.name.lastIndexOf('.'));
                    const randomPart = generateSecureRandomString(8, globalUsedNames);
                    const newName = `special_${randomPart}${extension}`;
                    renameMapping.special[file.name] = newName;
                    stats.special.toRename++;
                }
            });
            
            // Add collision protection statistics
            stats.collisionProtection = {
                totalReservedNames: globalUsedNames.size,
                newNamesGenerated: stats.follows.toRename + stats.subs.toRename + stats.special.toRename
            };
            
            // Display preview with smart filtering stats and collision info
            displayRenamePreview(stats);
            document.getElementById('renamePreview').classList.add('active');
            document.getElementById('applyBtn').disabled = false;
            document.getElementById('applyBtnCatbox').disabled = false;
            
            // Enable validation button for large batches (only count files to rename)
            const totalFilesToRename = Object.keys(renameMapping.follows).length + 
                                     Object.keys(renameMapping.subs).length + 
                                     Object.keys(renameMapping.special).length;
            
            const validateBtn = document.getElementById('validateBtn');
            if (totalFilesToRename >= 50) {
                validateBtn.disabled = false;
                validateBtn.style.display = 'inline-block';
            } else {
                validateBtn.style.display = 'none';
            }
            
            // Update button text to reflect optimization
            if (stats.follows.alreadyRenamed + stats.subs.alreadyRenamed + stats.special.alreadyRenamed > 0) {
                document.getElementById('applyBtn').innerHTML = `‚ö° Smart Process (${totalFilesToRename} new files)`;
            } else {
                document.getElementById('applyBtn').innerHTML = '‚úÖ Apply Rename & Generate Manifest';
            }
            
            // Log collision protection status
            console.log(`Collision Protection: ${globalUsedNames.size} existing names reserved, ${totalFilesToRename} new names generated`);
            if (globalUsedNames.size > 0) {
                console.log('Reserved names:', Array.from(globalUsedNames).slice(0, 10), globalUsedNames.size > 10 ? `... and ${globalUsedNames.size - 10} more` : '');
            }
        }

        // Display rename preview with smart filtering stats
        function displayRenamePreview(stats) {
            const container = document.getElementById('renameList');
            let html = '';
            
            // Show smart filtering statistics
            if (stats) {
                const totalAlreadyRenamed = stats.follows.alreadyRenamed + stats.subs.alreadyRenamed + stats.special.alreadyRenamed;
                const totalToRename = stats.follows.toRename + stats.subs.toRename + stats.special.toRename;
                const totalFiles = stats.follows.total + stats.subs.total + stats.special.total;
                
                if (totalAlreadyRenamed > 0) {
                    html += `
                        <div class="status success" style="margin-bottom: 20px;">
                            ‚ö° <strong>Smart Processing Optimization Active!</strong><br>
                            üìä <strong>Total files:</strong> ${totalFiles}<br>
                            ‚úÖ <strong>Already securely named:</strong> ${totalAlreadyRenamed} (will be preserved)<br>
                            üîÑ <strong>New files to rename:</strong> ${totalToRename}<br>
                            üõ°Ô∏è <strong>Collision protection:</strong> ${stats.collisionProtection ? stats.collisionProtection.totalReservedNames : 0} existing names reserved<br><br>
                            üí° <em>Processing time reduced by ${Math.round((totalAlreadyRenamed/totalFiles) * 100)}%!</em>
                        </div>
                        
                        <div class="stats" style="margin-bottom: 20px;">
                            <div class="stat-card">
                                <div class="stat-number" style="color: #27ae60;">${stats.follows.alreadyRenamed}</div>
                                <div class="stat-label">Follows Preserved</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number" style="color: #27ae60;">${stats.subs.alreadyRenamed}</div>
                                <div class="stat-label">Subs Preserved</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number" style="color: #27ae60;">${stats.special.alreadyRenamed}</div>
                                <div class="stat-label">Special Preserved</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number" style="color: #4a90e2;">${totalToRename}</div>
                                <div class="stat-label">New Files to Process</div>
                            </div>
                        </div>`;
                }
            }
            
            // Follow files
            if (Object.keys(renameMapping.follows).length > 0) {
                html += '<h4>üìÅ Follow Rewards</h4><div class="file-list">';
                Object.entries(renameMapping.follows).forEach(([oldName, newName]) => {
                    const fileType = getFileType(oldName);
                    html += `
                        <div class="file-item">
                            <span class="file-type ${fileType}">${fileType}</span>
                            <span class="file-name">${oldName}</span>
                            <span class="arrow">‚Üí</span>
                            <span class="file-name">${newName}</span>
                        </div>`;
                });
                html += '</div>';
            }
            
            // Sub files
            if (Object.keys(renameMapping.subs).length > 0) {
                html += '<h4>üìÅ Sub Rewards</h4><div class="file-list">';
                Object.entries(renameMapping.subs).forEach(([oldName, newName]) => {
                    const fileType = getFileType(oldName);
                    html += `
                        <div class="file-item">
                            <span class="file-type ${fileType}">${fileType}</span>
                            <span class="file-name">${oldName}</span>
                            <span class="arrow">‚Üí</span>
                            <span class="file-name">${newName}</span>
                        </div>`;
                });
                html += '</div>';
            }
            
            // Special files
            if (Object.keys(renameMapping.special).length > 0) {
                html += '<h4>‚≠ê Special Rewards</h4><div class="file-list">';
                Object.entries(renameMapping.special).forEach(([oldName, newName]) => {
                    const fileType = getFileType(oldName);
                    html += `
                        <div class="file-item">
                            <span class="file-type ${fileType}">${fileType}</span>
                            <span class="file-name">${oldName}</span>
                            <span class="arrow">‚Üí</span>
                            <span class="file-name">${newName}</span>
                        </div>`;
                });
                html += '</div>';
            }
            
            container.innerHTML = html;
        }

        // ===== ENTERPRISE-GRADE PROCESSING FUNCTIONS =====
        
        // Pre-validation for large batches
        async function validateBeforeRename() {
            const statusDiv = document.getElementById('renameStatus');
            const validateBtn = document.getElementById('validateBtn');
            
            try {
                validateBtn.disabled = true;
                statusDiv.innerHTML = '<div class="loading"><div class="spinner"></div>Pre-validating files for errors...</div>';
                
                const totalFiles = Object.keys(renameMapping.follows).length + 
                                 Object.keys(renameMapping.subs).length + 
                                 Object.keys(renameMapping.special).length;
                
                // Calculate API usage and time estimates
                const apiCallsNeeded = totalFiles * 3; // get, create, delete per file
                const estimatedMinutes = Math.ceil(apiCallsNeeded / 60); // ~60 calls per minute to be safe
                
                // Check GitHub API rate limits
                const rateLimitResponse = await fetch('https://api.github.com/rate_limit', {
                    headers: getGitHubHeaders()
                });
                
                if (rateLimitResponse.ok) {
                    const rateData = await rateLimitResponse.json();
                    const remaining = rateData.rate.remaining;
                    
                    if (apiCallsNeeded > remaining) {
                        statusDiv.innerHTML = `
                            <div class="status warning">
                                ‚ö†Ô∏è GitHub API Rate Limit Warning:<br>
                                <strong>Files to process:</strong> ${totalFiles}<br>
                                <strong>API calls needed:</strong> ${apiCallsNeeded}<br>
                                <strong>Calls remaining:</strong> ${remaining}<br><br>
                                <em>Processing will be automatically batched with delays to respect rate limits.</em><br>
                                <strong>Estimated time:</strong> ${estimatedMinutes} minutes
                            </div>`;
                    } else {
                        statusDiv.innerHTML = `
                            <div class="status success">
                                ‚úÖ Pre-validation Successful!<br>
                                <strong>Files to process:</strong> ${totalFiles}<br>
                                <strong>API calls needed:</strong> ${apiCallsNeeded}<br>
                                <strong>Calls available:</strong> ${remaining}<br>
                                <strong>Estimated time:</strong> ${estimatedMinutes} minutes<br><br>
                                <em>Safe to proceed with batch processing.</em>
                            </div>`;
                    }
                }
                
                // Test connectivity to a few sample files
                let connectivityErrors = 0;
                const sampleFiles = [];
                
                // Get sample files from each category
                if (currentFiles.follows.length > 0) sampleFiles.push({folder: 'images/follows', file: currentFiles.follows[0]});
                if (currentFiles.subs.length > 0) sampleFiles.push({folder: 'images/subs', file: currentFiles.subs[0]});
                if (currentFiles.special.length > 0) sampleFiles.push({folder: 'images/special', file: currentFiles.special[0]});
                
                for (const sample of sampleFiles) {
                    try {
                        const actualPath = window.detectedPaths && window.detectedPaths[sample.folder] 
                            ? window.detectedPaths[sample.folder] 
                            : sample.folder;
                            
                        const testResponse = await fetch(`https://api.github.com/repos/${getRepoInfo().owner}/${getRepoInfo().repo}/contents/${actualPath}/${sample.file.name}`, {
                            headers: getGitHubHeaders()
                        });
                        
                        if (!testResponse.ok) {
                            connectivityErrors++;
                            console.warn(`Connectivity test failed for ${sample.file.name}`);
                        }
                    } catch (error) {
                        connectivityErrors++;
                        console.warn(`Connectivity error: ${error.message}`);
                    }
                }
                
                if (connectivityErrors > 0) {
                    statusDiv.innerHTML += `<div class="status warning">‚ö†Ô∏è ${connectivityErrors} connectivity issues detected. Processing may encounter errors.</div>`;
                }
                
                // Show batch processing options
                document.getElementById('applyBtn').innerHTML = 'üöÄ Start Batch Processing';
                document.getElementById('applyBtn').style.background = 'linear-gradient(45deg, #e74c3c, #c0392b)';
                
            } catch (error) {
                statusDiv.innerHTML = `<div class="status error">‚ùå Validation failed: ${error.message}</div>`;
            } finally {
                validateBtn.disabled = false;
            }
        }
        
        // Batch processing with rate limiting
        async function processBatch(files, folder, batchSize = 10) {
            const results = { success: [], errors: [] };
            
            for (let i = 0; i < files.length; i += batchSize) {
                const batch = files.slice(i, i + batchSize);
                
                // Update progress
                processingState.currentBatch++;
                updateProgressDisplay();
                
                // Process batch
                for (const [oldName, newName] of batch) {
                    try {
                        await renameFile(folder, oldName, newName);
                        results.success.push({ old: oldName, new: newName });
                        processingState.processed++;
                        processingState.completed.push({ folder, old: oldName, new: newName });
                        
                        // Update progress after each file
                        updateProgressDisplay();
                        
                    } catch (error) {
                        const errorInfo = { folder, old: oldName, new: newName, error: error.message };
                        results.errors.push(errorInfo);
                        processingState.errors.push(errorInfo);
                        console.error(`Rename failed: ${oldName} -> ${newName}`, error);
                    }
                }
                
                // Rate limiting: pause between batches
                if (i + batchSize < files.length) {
                    await new Promise(resolve => setTimeout(resolve, 2000)); // 2 second pause
                }
            }
            
            return results;
        }
        
        // Progress display update
        function updateProgressDisplay() {
            const statusDiv = document.getElementById('renameStatus');
            const progress = processingState.total > 0 ? (processingState.processed / processingState.total) * 100 : 0;
            const elapsed = processingState.startTime ? (Date.now() - processingState.startTime) / 1000 : 0;
            const eta = progress > 0 ? (elapsed / progress * 100 - elapsed) : 0;
            
            statusDiv.innerHTML = `
                <div class="status info">
                    üîÑ Processing Files: ${processingState.processed}/${processingState.total} (${Math.round(progress)}%)<br>
                    üìä Batch: ${processingState.currentBatch}/${processingState.totalBatches}<br>
                    ‚è±Ô∏è Elapsed: ${Math.round(elapsed)}s | ETA: ${Math.round(eta)}s<br>
                    ${processingState.errors.length > 0 ? `‚ùå Errors: ${processingState.errors.length}<br>` : ''}
                    <div style="background: #e1e8ed; border-radius: 10px; height: 10px; margin: 10px 0;">
                        <div style="background: linear-gradient(45deg, #4a90e2, #357abd); height: 100%; border-radius: 10px; width: ${progress}%; transition: width 0.3s ease;"></div>
                    </div>
                </div>`;
        }
        
        // Resume processing function
        async function resumeProcessing() {
            if (!processingState.isRunning) {
                processingState.isRunning = true;
                document.getElementById('resumeBtn').disabled = true;
                
                // Continue from where we left off
                await continueRenameProcess();
                
                processingState.isRunning = false;
                document.getElementById('resumeBtn').disabled = false;
            }
        }
        
        // Resume rename function
        async function resumeRename() {
            await resumeProcessing();
        }
        
        // Continue rename process (for resuming)
        async function continueRenameProcess() {
            const statusDiv = document.getElementById('renameStatus');
            
            // This would need to be implemented based on saved state
            // For now, show message about starting from scratch
            statusDiv.innerHTML = `
                <div class="status warning">
                    ‚ö†Ô∏è Resume functionality is a placeholder in this version.<br>
                    For safety, please restart the entire process using "Apply Rename & Generate Manifest".<br>
                    Your progress has been logged for troubleshooting purposes.
                </div>`;
        }

        // Retry manifest generation only
        async function retryManifest() {
            const statusDiv = document.getElementById('renameStatus');
            const retryBtn = document.getElementById('retryManifestBtn');
            
            try {
                retryBtn.disabled = true;
                statusDiv.innerHTML = '<div class="loading"><div class="spinner"></div>Retrying manifest generation...</div>';
                
                await generateAndUploadManifest();
                
                statusDiv.innerHTML = '<div class="status success">‚úÖ Manifest.json generated successfully!</div>';
                document.getElementById('downloadBtn').disabled = false;
                retryBtn.style.display = 'none';
                
            } catch (error) {
                statusDiv.innerHTML = `<div class="status error">‚ùå Manifest generation still failing: ${error.message}<br><br>Check browser console (F12) for detailed error information.</div>`;
            } finally {
                retryBtn.disabled = false;
            }
        }

        // Enterprise-grade apply rename with batch processing
        async function applyRename() {
            const statusDiv = document.getElementById('renameStatus');
            const applyBtn = document.getElementById('applyBtn');
            
            try {
                applyBtn.disabled = true;
                
                // CRITICAL: Validate no collisions before starting
                try {
                    validateNoCollisions(renameMapping);
                } catch (collisionError) {
                    statusDiv.innerHTML = `
                        <div class="status error">
                            üö® <strong>COLLISION DETECTED!</strong><br>
                            ${collisionError.message}<br><br>
                            <em>Please click "Preview Rename" again to regenerate collision-free names.</em>
                        </div>`;
                    applyBtn.disabled = false;
                    return;
                }
                
                // Initialize processing state
                processingState = {
                    isRunning: true,
                    currentBatch: 0,
                    totalBatches: 0,
                    processed: 0,
                    total: 0,
                    errors: [],
                    completed: [],
                    startTime: Date.now()
                };
                
                // Calculate totals
                const followFiles = Object.entries(renameMapping.follows);
                const subFiles = Object.entries(renameMapping.subs);
                const specialFiles = Object.entries(renameMapping.special);
                
                processingState.total = followFiles.length + subFiles.length + specialFiles.length;
                processingState.totalBatches = Math.ceil(followFiles.length / 10) + 
                                             Math.ceil(subFiles.length / 10) + 
                                             Math.ceil(specialFiles.length / 10);
                
                // Show initial progress
                updateProgressDisplay();
                
                // Process each category in batches
                let allResults = { success: [], errors: [] };
                
                // Process follows
                if (followFiles.length > 0) {
                    const followResults = await processBatch(followFiles, 'images/follows', 10);
                    allResults.success.push(...followResults.success);
                    allResults.errors.push(...followResults.errors);
                }
                
                // Process subs
                if (subFiles.length > 0) {
                    const subResults = await processBatch(subFiles, 'images/subs', 10);
                    allResults.success.push(...subResults.success);
                    allResults.errors.push(...subResults.errors);
                }
                
                // Process special
                if (specialFiles.length > 0) {
                    const specialResults = await processBatch(specialFiles, 'images/special', 10);
                    allResults.success.push(...specialResults.success);
                    allResults.errors.push(...specialResults.errors);
                }
                
                // Generate and upload manifest
                statusDiv.innerHTML = '<div class="loading"><div class="spinner"></div>Generating and uploading manifest.json...</div>';
                try {
                    await generateAndUploadManifest();
                    
                    const finalStatus = allResults.errors.length > 0 
                        ? `‚ö†Ô∏è Completed with ${allResults.errors.length} errors: ${allResults.success.length}/${processingState.total} files renamed successfully and manifest.json generated!`
                        : `‚úÖ Perfect! All ${allResults.success.length} files renamed successfully and manifest.json generated!`;
                    
                    statusDiv.innerHTML = `<div class="status ${allResults.errors.length > 0 ? 'warning' : 'success'}">${finalStatus}</div>`;
                    
                    if (allResults.errors.length > 0) {
                        // Show error details
                        const errorDetails = allResults.errors.map(e => `${e.old}: ${e.error}`).join('<br>');
                        statusDiv.innerHTML += `<details><summary>View Error Details</summary><div style="font-family: monospace; font-size: 0.9rem; margin-top: 10px;">${errorDetails}</div></details>`;
                    }
                    
                    document.getElementById('downloadBtn').disabled = false;
                    await scanRepository();
                    
                } catch (manifestError) {
                    statusDiv.innerHTML = `
                        <div class="status warning">
                            ‚ö†Ô∏è Files processed (${allResults.success.length}/${processingState.total} successful), but manifest generation failed:<br>
                            <strong>${manifestError.message}</strong><br><br>
                            <em>Your files have secure names and are accessible, but StreamerBot integration requires the manifest file.</em>
                        </div>`;
                    
                    document.getElementById('retryManifestBtn').style.display = 'inline-block';
                    document.getElementById('retryManifestBtn').disabled = false;
                    await scanRepository();
                }
                
                processingState.isRunning = false;
                
            } catch (error) {
                statusDiv.innerHTML = `<div class="status error">‚ùå Batch processing failed: ${error.message}</div>`;
                processingState.isRunning = false;
                
                // Show resume button if some files were processed
                if (processingState.processed > 0) {
                    document.getElementById('resumeBtn').style.display = 'inline-block';
                    document.getElementById('resumeBtn').disabled = false;
                }
            } finally {
                applyBtn.disabled = false;
            }
        }

        // Apply rename with Catbox upload for privacy
        async function applyRenameWithCatbox() {
            const applyBtn = document.getElementById('applyBtnCatbox');
            const statusDiv = document.getElementById('renameStatus');
            
            if (!currentFiles || (currentFiles.follows.length === 0 && currentFiles.subs.length === 0 && currentFiles.special.length === 0)) {
                alert('No files found. Please scan your repository first.');
                return;
            }

            try {
                applyBtn.disabled = true;
                applyBtn.textContent = 'üîí Processing...';
                
                statusDiv.innerHTML = '<div class="status info">üöÄ Starting rename and Catbox upload process...</div>';
                
                // Step 1: Apply renames in GitHub (same as regular flow)
                await processBatch(
                    (message) => statusDiv.innerHTML += `<div class="status info">${message}</div>`,
                    async () => {
                        await generateAndUploadManifest();
                    }
                );
                
                // Step 2: Upload all files to Catbox
                statusDiv.innerHTML += '<div class="status info">üìÅ Now uploading files to Catbox for privacy...</div>';
                
                await uploadFilesToCatbox((message) => {
                    statusDiv.innerHTML += `<div class="status info">${message}</div>`;
                });
                
                // Step 3: Generate manifest with Catbox URLs
                statusDiv.innerHTML += '<div class="status info">üìù Generating manifest with Catbox URLs...</div>';
                await generateAndUploadManifest();
                
                statusDiv.innerHTML += `
                    <div class="status success">
                        üéâ <strong>Complete! Files renamed and uploaded to Catbox!</strong><br><br>
                        ‚úÖ <strong>Privacy:</strong> Files hosted on Catbox.moe (anonymous)<br>
                        ‚úÖ <strong>Security:</strong> GitHub repository can be made private<br>
                        ‚úÖ <strong>Functionality:</strong> StreamerBot will use Catbox URLs<br><br>
                        üîó Your reward links are now completely private!
                    </div>
                `;
                
                // Enable download
                document.getElementById('downloadBtn').disabled = false;
                
            } catch (error) {
                console.error('Catbox upload error:', error);
                statusDiv.innerHTML += `
                    <div class="status error">
                        ‚ùå <strong>Error during Catbox upload:</strong><br>
                        ${error.message}<br><br>
                        üí° <strong>Fallback:</strong> Files were renamed in GitHub successfully. 
                        You can try the regular "Generate Manifest" if needed.
                    </div>
                `;
            } finally {
                applyBtn.disabled = false;
                applyBtn.textContent = 'üîí Apply Rename & Upload to Catbox (Private)';
            }
        }

        // Rename individual file via GitHub API
        async function renameFile(folder, oldName, newName) {
            const { owner, repo } = getRepoInfo();
            
            // Use the detected path for this folder
            const actualPath = window.detectedPaths && window.detectedPaths[folder] 
                ? window.detectedPaths[folder] 
                : folder;
            
            // Get file content
            const getResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${actualPath}/${oldName}`, {
                headers: getGitHubHeaders()
            });
            
            if (!getResponse.ok) {
                throw new Error(`Failed to get file ${oldName}: ${getResponse.statusText}`);
            }
            
            const fileData = await getResponse.json();
            
            // Create new file
            await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${actualPath}/${newName}`, {
                method: 'PUT',
                headers: getGitHubHeaders(),
                body: JSON.stringify({
                    message: `Rename ${oldName} to ${newName}`,
                    content: fileData.content
                })
            });
            
            // Delete old file
            await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${actualPath}/${oldName}`, {
                method: 'DELETE',
                headers: getGitHubHeaders(),
                body: JSON.stringify({
                    message: `Remove old file ${oldName}`,
                    sha: fileData.sha
                })
            });
        }

        // Generate manifest files with Catbox URLs for privacy
        function generateManifestFiles(category, allFiles, path, owner, repo) {
            return allFiles.map(file => {
                let filename;
                
                // Use new name if file was just renamed, otherwise use existing name
                if (renameMapping[category] && renameMapping[category][file.name]) {
                    filename = renameMapping[category][file.name]; // Newly renamed
                } else {
                    filename = file.name; // Already renamed or using original name
                }
                
                // Use Catbox URL if available, otherwise fallback to GitHub
                let finalUrl = `https://${owner.toLowerCase()}.github.io/${repo}/${path}/${filename}`;
                if (catboxUrls[category] && catboxUrls[category][filename]) {
                    finalUrl = catboxUrls[category][filename];
                }
                
                return {
                    filename: filename,
                    url: finalUrl,
                    type: getFileType(filename),
                    source: catboxUrls[category] && catboxUrls[category][filename] ? 'catbox' : 'github'
                };
            });
        }

        // Generate and upload manifest
        async function generateAndUploadManifest() {
            const { owner, repo } = getRepoInfo();
            
            // Build manifest data using detected paths
            const followsPath = window.detectedPaths && window.detectedPaths['images/follows'] 
                ? window.detectedPaths['images/follows'] 
                : 'images/follows';
            const subsPath = window.detectedPaths && window.detectedPaths['images/subs'] 
                ? window.detectedPaths['images/subs'] 
                : 'images/subs';
            const specialPath = window.detectedPaths && window.detectedPaths['images/special'] 
                ? window.detectedPaths['images/special'] 
                : 'images/special';
            
            manifestData = {
                generated: new Date().toISOString(),
                base_url: `https://${owner.toLowerCase()}.github.io/${repo}`,
                detected_structure: {
                    follows_path: followsPath,
                    subs_path: subsPath,
                    special_path: specialPath
                },
                follows: {
                    count: currentFiles.follows.length,
                    files: generateManifestFiles('follows', currentFiles.follows, followsPath, owner, repo)
                },
                subs: {
                    count: currentFiles.subs.length,
                    files: generateManifestFiles('subs', currentFiles.subs, subsPath, owner, repo)
                },
                special: {
                    count: currentFiles.special.length,
                    files: generateManifestFiles('special', currentFiles.special, specialPath, owner, repo)
                },
                special_videos: {
                    count: specialVideoUrls.length,
                    files: specialVideoUrls.map(url => ({
                        filename: url.split('/').pop() || 'video',
                        url: url,
                        type: 'video',
                        source: 'external'
                    }))
                }
            };
            
            // Upload manifest to repository
            console.log('Generated manifest data:', manifestData);
            
            const manifestJson = JSON.stringify(manifestData, null, 2);
            console.log('Manifest JSON length:', manifestJson.length);
            
            const manifestContent = btoa(manifestJson);
            console.log('Base64 content length:', manifestContent.length);
            
            // Check if manifest exists
            let sha = null;
            try {
                const existingResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/manifest.json`, {
                    headers: getGitHubHeaders()
                });
                if (existingResponse.ok) {
                    const existingData = await existingResponse.json();
                    sha = existingData.sha;
                }
            } catch (error) {
                // File doesn't exist, that's fine
            }
            
            const body = {
                message: 'Update manifest.json with renamed files',
                content: manifestContent
            };
            if (sha) body.sha = sha;
            
            const uploadResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/manifest.json`, {
                method: 'PUT',
                headers: getGitHubHeaders(),
                body: JSON.stringify(body)
            });
            
            if (!uploadResponse.ok) {
                const errorData = await uploadResponse.json().catch(() => null);
                const errorMessage = errorData ? 
                    `HTTP ${uploadResponse.status}: ${errorData.message || uploadResponse.statusText}` :
                    `HTTP ${uploadResponse.status}: ${uploadResponse.statusText}`;
                throw new Error(`Failed to upload manifest.json - ${errorMessage}`);
            }
            
            // Display manifest preview
            displayManifestPreview();
        }

        // Display manifest preview
        function displayManifestPreview() {
            const container = document.getElementById('manifestPreview');
            const { owner, repo } = getRepoInfo();
            
            container.innerHTML = `
                <div class="status success">
                    <strong>üìÑ Manifest Generated Successfully!</strong><br>
                    <strong>StreamerBot URL:</strong> <code>https://${owner.toLowerCase()}.github.io/${repo}/manifest.json</code>
                </div>
                <details>
                    <summary>View Manifest Contents</summary>
                    <pre style="background: #f8f9fa; padding: 15px; border-radius: 5px; overflow-x: auto; font-size: 0.9rem;">${JSON.stringify(manifestData, null, 2)}</pre>
                </details>`;
        }

        // Download manifest file
        function downloadManifest() {
            if (!manifestData) return;
            
            const blob = new Blob([JSON.stringify(manifestData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'manifest.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Utility functions
        function getFileType(filename) {
            const extension = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            if (['.png', '.jpg', '.jpeg', '.webp'].includes(extension)) return 'image';
            if (['.gif'].includes(extension)) return 'gif';
            if (['.mp4', '.mov', '.avi'].includes(extension)) return 'video';
            return 'unknown';
        }

        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        // Save/load settings from browser storage
        function saveSettings() {
            const token = document.getElementById('githubToken').value;
            const owner = document.getElementById('repoOwner').value;
            const repo = document.getElementById('repoName').value;
            
            if (token) {
                localStorage.setItem('streamRewards_token', token);
                localStorage.setItem('streamRewards_owner', owner);
                localStorage.setItem('streamRewards_repo', repo);
            }
        }
        
        function loadSettings() {
            const savedToken = localStorage.getItem('streamRewards_token');
            const savedOwner = localStorage.getItem('streamRewards_owner');
            const savedRepo = localStorage.getItem('streamRewards_repo');
            
            if (savedToken) {
                document.getElementById('githubToken').value = savedToken;
            }
            if (savedOwner) {
                document.getElementById('repoOwner').value = savedOwner;
            }
            if (savedRepo) {
                document.getElementById('repoName').value = savedRepo;
            }
        }
        
        function clearSettings() {
            localStorage.removeItem('streamRewards_token');
            localStorage.removeItem('streamRewards_owner');
            localStorage.removeItem('streamRewards_repo');
            
            document.getElementById('githubToken').value = '';
            document.getElementById('repoOwner').value = 'KayPikeFashion';
            document.getElementById('repoName').value = 'stream_rewards';
            
            document.getElementById('connectionStatus').innerHTML = '<div class="status warning">‚ö†Ô∏è Settings cleared. Please enter your token again.</div>';
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            // Load saved settings
            loadSettings();
            
            // Auto-fill GitHub info from URL if available
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('owner')) {
                document.getElementById('repoOwner').value = urlParams.get('owner');
            }
            if (urlParams.get('repo')) {
                document.getElementById('repoName').value = urlParams.get('repo');
            }
            
            // Auto-save settings when changed
            document.getElementById('githubToken').addEventListener('input', saveSettings);
            document.getElementById('repoOwner').addEventListener('input', saveSettings);
            document.getElementById('privateRepoName').addEventListener('input', saveSettings);
            document.getElementById('publicRepoName').addEventListener('input', saveSettings);
            
            // Load saved video URLs
            loadVideoUrls();
        });

        // Video URL Management Functions
        function addVideoUrl() {
            const input = document.getElementById('videoUrlInput');
            const url = input.value.trim();
            
            if (!url) {
                alert('Please enter a valid video URL');
                return;
            }
            
            // Basic URL validation
            try {
                new URL(url);
            } catch (e) {
                alert('Please enter a valid URL (must start with http:// or https://)');
                return;
            }
            
            // Check for duplicates
            if (specialVideoUrls.includes(url)) {
                alert('This URL is already in your list');
                return;
            }
            
            // Add to array and update display
            specialVideoUrls.push(url);
            input.value = '';
            updateVideoUrlDisplay();
            saveVideoUrls();
            
            console.log('Added video URL:', url);
        }
        
        function removeVideoUrl(index) {
            if (confirm('Are you sure you want to remove this video URL?')) {
                specialVideoUrls.splice(index, 1);
                updateVideoUrlDisplay();
                saveVideoUrls();
                console.log('Removed video URL at index:', index);
            }
        }
        
        function updateVideoUrlDisplay() {
            const listDiv = document.getElementById('videoUrlList');
            const statsDiv = document.getElementById('videoStats');
            const countDiv = document.getElementById('videoCount');
            
            if (specialVideoUrls.length === 0) {
                listDiv.innerHTML = '<div class="status info">No special video URLs added yet.</div>';
                statsDiv.style.display = 'none';
                return;
            }
            
            // Show stats
            statsDiv.style.display = 'block';
            countDiv.textContent = specialVideoUrls.length;
            
            // Generate URL list HTML
            let html = '<h3>üìπ Current Video URLs:</h3>';
            html += '<div class="file-list">';
            
            specialVideoUrls.forEach((url, index) => {
                const domain = new URL(url).hostname;
                const filename = url.split('/').pop() || 'video';
                
                html += `
                    <div class="file-item">
                        <div>
                            <span class="file-type video">VIDEO</span>
                            <span class="file-name">${filename}</span>
                            <small style="color: #666;">${domain}</small>
                        </div>
                        <div>
                            <a href="${url}" target="_blank" style="margin-right: 10px; color: #4a90e2;">üîó View</a>
                            <button onclick="removeVideoUrl(${index})" style="background: #e74c3c; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">üóëÔ∏è Remove</button>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            listDiv.innerHTML = html;
        }
        
        function saveVideoUrls() {
            localStorage.setItem('specialVideoUrls', JSON.stringify(specialVideoUrls));
        }
        
        function loadVideoUrls() {
            const saved = localStorage.getItem('specialVideoUrls');
            if (saved) {
                try {
                    specialVideoUrls = JSON.parse(saved);
                    updateVideoUrlDisplay();
                } catch (e) {
                    console.warn('Failed to load saved video URLs:', e);
                    specialVideoUrls = [];
                }
            }
        }
        
        function clearVideoUrls() {
            if (confirm('Are you sure you want to clear all video URLs? This cannot be undone.')) {
                specialVideoUrls = [];
                updateVideoUrlDisplay();
                saveVideoUrls();
            }
        }

        // Upload file to Catbox.moe for anonymous hosting
        async function uploadToCatbox(fileBlob, filename) {
            try {
                const formData = new FormData();
                formData.append('reqtype', 'fileupload');
                formData.append('fileToUpload', fileBlob, filename);

                const response = await fetch('https://catbox.moe/user/api.php', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`Catbox upload failed: ${response.status}`);
                }

                const result = await response.text();
                
                // Catbox returns the direct URL as plain text
                if (result.startsWith('https://files.catbox.moe/')) {
                    return result.trim();
                } else {
                    throw new Error(`Invalid Catbox response: ${result}`);
                }
            } catch (error) {
                console.error('Catbox upload error:', error);
                throw error;
            }
        }

        // Upload all files to Catbox for anonymous hosting
        async function uploadFilesToCatbox(statusCallback) {
            const { owner, repo } = getRepoInfo();
            catboxUrls = { follows: {}, subs: {}, special: {} };
            
            let totalFiles = 0;
            let uploadedFiles = 0;
            let errors = [];

            // Count total files to upload
            ['follows', 'subs', 'special'].forEach(category => {
                totalFiles += currentFiles[category].length;
            });

            statusCallback(`üöÄ Starting upload of ${totalFiles} files to Catbox.moe...`);

            // Upload files by category
            for (const category of ['follows', 'subs', 'special']) {
                const files = currentFiles[category];
                if (files.length === 0) continue;

                statusCallback(`üìÅ Uploading ${files.length} ${category} files to Catbox...`);

                for (const file of files) {
                    try {
                        // Determine final filename (renamed or original)
                        let filename = file.name;
                        if (renameMapping[category] && renameMapping[category][file.name]) {
                            filename = renameMapping[category][file.name];
                        }

                        // Get file content from GitHub
                        const path = window.detectedPaths && window.detectedPaths[`images/${category}`] 
                            ? window.detectedPaths[`images/${category}`] 
                            : `images/${category}`;
                        
                        const fileUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${path}/${file.name}`;
                        const fileResponse = await fetch(fileUrl, {
                            headers: getGitHubHeaders()
                        });

                        if (!fileResponse.ok) {
                            throw new Error(`Failed to fetch file: ${fileResponse.status}`);
                        }

                        const fileData = await fileResponse.json();
                        const fileContent = atob(fileData.content.replace(/\\s/g, ''));
                        
                        // Convert to blob
                        const byteArray = new Uint8Array(fileContent.length);
                        for (let i = 0; i < fileContent.length; i++) {
                            byteArray[i] = fileContent.charCodeAt(i);
                        }
                        const fileBlob = new Blob([byteArray]);

                        // Upload to Catbox
                        const catboxUrl = await uploadToCatbox(fileBlob, filename);
                        catboxUrls[category][filename] = catboxUrl;
                        uploadedFiles++;

                        statusCallback(`‚úÖ Uploaded ${uploadedFiles}/${totalFiles}: ${filename}`);
                        
                        // Small delay to be respectful to Catbox servers
                        await new Promise(resolve => setTimeout(resolve, 1000));

                    } catch (error) {
                        console.error(`Upload error for ${file.name}:`, error);
                        errors.push(`${file.name}: ${error.message}`);
                        statusCallback(`‚ùå Failed ${file.name}: ${error.message}`);
                    }
                }
            }

            if (errors.length > 0) {
                throw new Error(`Upload completed with ${errors.length} errors: ${errors.join(', ')}`);
            }

            statusCallback(`üéâ Successfully uploaded ${uploadedFiles} files to Catbox!`);
            return catboxUrls;
        }

        // Quick Manifest Regeneration (no file renaming)
        async function regenerateManifestOnly() {
            const regenBtn = document.getElementById('regenBtn');
            const statusDiv = document.getElementById('regenStatus');
            
            try {
                regenBtn.disabled = true;
                regenBtn.textContent = 'üîÑ Regenerating...';
                
                statusDiv.innerHTML = '<div class="status info">üîç Scanning repository for existing files...</div>';
                
                // Step 1: Scan repository to find all current files
                const followsFiles = await scanFolder('images/follows');
                const subsFiles = await scanFolder('images/subs');
                const specialFiles = await scanFolder('images/special');
                
                // Update current files
                currentFiles = { 
                    follows: followsFiles, 
                    subs: subsFiles, 
                    special: specialFiles 
                };
                
                statusDiv.innerHTML = `
                    <div class="status success">
                        üìä <strong>Files Found:</strong><br>
                        ‚Ä¢ Follow rewards: ${followsFiles.length}<br>
                        ‚Ä¢ Sub rewards: ${subsFiles.length}<br>
                        ‚Ä¢ Special rewards: ${specialFiles.length}<br>
                        ‚Ä¢ Video URLs: ${specialVideoUrls.length}
                    </div>
                `;
                
                // Step 2: Generate manifest with all current files (no renaming)
                statusDiv.innerHTML += '<div class="status info">üìù Generating fresh manifest...</div>';
                
                // Clear rename mapping since we're not renaming anything
                renameMapping = { follows: {}, subs: {}, special: {} };
                
                // Generate and upload manifest
                await generateAndUploadManifest();
                
                statusDiv.innerHTML = `
                    <div class="status success">
                        ‚úÖ <strong>Manifest Successfully Regenerated!</strong><br><br>
                        üìä <strong>Updated Stats:</strong><br>
                        ‚Ä¢ Follow rewards: ${followsFiles.length} files<br>
                        ‚Ä¢ Sub rewards: ${subsFiles.length} files<br>
                        ‚Ä¢ Special rewards: ${specialFiles.length} files<br>
                        ‚Ä¢ Video URLs: ${specialVideoUrls.length} videos<br><br>
                        üéØ Your StreamerBot reward system is ready to go!
                    </div>
                `;
                
                // Update file stats display
                document.getElementById('followCount').textContent = followsFiles.length;
                document.getElementById('subCount').textContent = subsFiles.length;
                document.getElementById('specialCount').textContent = specialFiles.length;
                document.getElementById('totalCount').textContent = followsFiles.length + subsFiles.length + specialFiles.length;
                document.getElementById('fileStats').style.display = 'grid';
                
                // Enable download
                document.getElementById('downloadBtn').disabled = false;
                
            } catch (error) {
                console.error('Regenerate manifest error:', error);
                statusDiv.innerHTML = `
                    <div class="status error">
                        ‚ùå <strong>Error regenerating manifest:</strong><br>
                        ${error.message}<br><br>
                        üí° <strong>Try again or check your GitHub connection.</strong>
                    </div>
                `;
            } finally {
                regenBtn.disabled = false;
                regenBtn.textContent = 'üîÑ Regenerate Manifest Only';
            }
        }

        // Regenerate manifest with Catbox upload
        async function regenerateWithCatbox() {
            const regenBtn = document.getElementById('regenBtnCatbox');
            const statusDiv = document.getElementById('regenStatus');
            
            try {
                regenBtn.disabled = true;
                regenBtn.textContent = 'üîí Processing...';
                
                statusDiv.innerHTML = '<div class="status info">üîç Scanning repository for existing files...</div>';
                
                // Step 1: Scan repository to find all current files
                const followsFiles = await scanFolder('images/follows');
                const subsFiles = await scanFolder('images/subs');
                const specialFiles = await scanFolder('images/special');
                
                // Update current files
                currentFiles = { 
                    follows: followsFiles, 
                    subs: subsFiles, 
                    special: specialFiles 
                };
                
                statusDiv.innerHTML = `
                    <div class="status success">
                        üìä <strong>Files Found:</strong><br>
                        ‚Ä¢ Follow rewards: ${followsFiles.length}<br>
                        ‚Ä¢ Sub rewards: ${subsFiles.length}<br>
                        ‚Ä¢ Special rewards: ${specialFiles.length}<br>
                        ‚Ä¢ Video URLs: ${specialVideoUrls.length}
                    </div>
                `;
                
                // Step 2: Upload all files to Catbox
                statusDiv.innerHTML += '<div class="status info">üìÅ Uploading files to Catbox for privacy...</div>';
                
                // Clear rename mapping since we're not renaming anything
                renameMapping = { follows: {}, subs: {}, special: {} };
                
                await uploadFilesToCatbox((message) => {
                    statusDiv.innerHTML += `<div class="status info">${message}</div>`;
                });
                
                // Step 3: Generate manifest with Catbox URLs
                statusDiv.innerHTML += '<div class="status info">üìù Generating manifest with Catbox URLs...</div>';
                await generateAndUploadManifest();
                
                statusDiv.innerHTML += `
                    <div class="status success">
                        ‚úÖ <strong>Manifest Successfully Regenerated with Catbox URLs!</strong><br><br>
                        üìä <strong>Privacy Stats:</strong><br>
                        ‚Ä¢ Follow rewards: ${followsFiles.length} files ‚Üí Catbox hosted<br>
                        ‚Ä¢ Sub rewards: ${subsFiles.length} files ‚Üí Catbox hosted<br>
                        ‚Ä¢ Special rewards: ${specialFiles.length} files ‚Üí Catbox hosted<br>
                        ‚Ä¢ Video URLs: ${specialVideoUrls.length} videos<br><br>
                        üîí Your StreamerBot reward system is now completely private!
                    </div>
                `;
                
                // Update file stats display
                document.getElementById('followCount').textContent = followsFiles.length;
                document.getElementById('subCount').textContent = subsFiles.length;
                document.getElementById('specialCount').textContent = specialFiles.length;
                document.getElementById('totalCount').textContent = followsFiles.length + subsFiles.length + specialFiles.length;
                document.getElementById('fileStats').style.display = 'grid';
                
                // Enable download
                document.getElementById('downloadBtn').disabled = false;
                
            } catch (error) {
                console.error('Regenerate with Catbox error:', error);
                statusDiv.innerHTML += `
                    <div class="status error">
                        ‚ùå <strong>Error regenerating with Catbox:</strong><br>
                        ${error.message}<br><br>
                        üí° <strong>Try the regular regenerate or check your GitHub connection.</strong>
                    </div>
                `;
            } finally {
                regenBtn.disabled = false;
                regenBtn.textContent = 'üîí Regenerate & Upload to Catbox';
            }
        }
    </script>
</body>
</html>
